# Refactoring

- [리팩터링 2판](https://product.kyobobook.co.kr/detail/S000001810241)
- [인프런 - 코드로 학습하는 리팩토링](https://inf.run/HJCN)

❗️ **코드 실행을 위한 사전 작업**

`home` 디렉토리에 `.github` 파일 생성 후 **repos** 권한을 가진 github personal access token 등록 필요

```yaml
oauth=GITHUB_PERSONAL_ACCESS_TOKEN
```

---

1. 이해하기 힘든 이름 (Mysterious Name)
    1. 함수 선언 변경하기 (Change Function Declaration)
        - 함수 이름
            - 함수의 구현 코드를 볼 필요 없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있도록 작성
            - 함수의 기능을 설명하는 주석 작성 -> 주석 이름으로 함수 이름 만들어보기
        - 매개변수
            - 함수 내부의 문맥 결정
            - 의존성 결정 (활용 범위 결정 + 다른 모듈과의 결합도 결정)
    2. 변수 이름 바꾸기 (Rename Variable)
        - 사용 범위(scope)에 따라 중요도가 달라짐 (람다식에서 사용하는 변수 vs 함수의 매개변수)
    3.  필드 이름 바꾸기 (Rename Field)
        - `Record`의 필드 이름은 프로그램 전반에 걸쳐 참조되므로 매우 중요

2. 중복 코드 (Duplicated Code)
    1. 함수 추출하기 (Extract Function)
        - **의도**와 **구현** 분리하기
            - 의도 -> 이름을 통해 *어떻게가 아닌* **무엇을** 하는지 파악할 수 있도록 작성
            - 구현 -> 내부 코드로 확인하도록 작성
    2. 코드 정리하기 (Slide Statements)
        - 관련 있는 코드끼리 근처에 두기
    3. 메소드 올리기 (Pull Up Method)
        - 여러 하위 클래스에 동일한 코드가 있다면 **상위 클래스**로 올리기
        - 한쪽에서만 코드를 수정해 버그가 발생하는 경우 방지
       
3. 긴 함수 (Long Function)
    1. 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)
        - 매개변수 감소
        - 코드 중복 감소
    2. 매개변수 객체 만들기 (Introduce Parameter Object)
        - 비슷한 매개변수가 계속해서 같이 넘겨질 때 사용
        - 데이터 사이의 관계가 명확해짐
        - 매개변수 수 감소
        - 모든 함수가 원소 참조 시 같은 이름 사용하므로 일관성 증가
    3. 객체 통째로 넘기기 (Preserve Whole Object)
        - 코드 변화에 대응 쉬움
        - 레코드에 담긴 데이터 중 일부를 받는 함수가 여러 개라면 그 함수들이 같은 데이터를 사용하는 부분이 있을 것이고, 그 부분의 로직이 중복될 가능성 높음
        - 똑같은 일부만 사용하는 코드가 많다면 => 따로 묶어서 클래스로 추출하라는 악취일 수도 (클래스 추출하기, Extract Class)
        - 이 리팩토링을 실행하지 않는 경우
          - 함수가 레코드에 의존하기를 원하지 않을 때
          - 레코드와 함수가 다른 모듈에 있을 때
    4. 함수를 명령으로 바꾸기 (Replace Function with Command)
        - 디자인 패턴 중 **커맨터 패턴**과 유사
        - 함수 분리를 한 후 위치가 잘못된 것 같거나, 향후 더 복잡해질거 같을 때 고려
        - 명령 객체 : 요청을 캡슐화한 객체
          - 대부분 **메소드 하나**로 구성되며, 이 메소드를 요청해 실행하는 것이 이 객체의 목적
          - 되돌리기(undo)같은 보조 연산 제공 가능
          - 수명주기 정밀하게 제어 가능
          - 상속, 훅(hook)으로 사용자 맞춤 가능
          - 일급 함수(first-class function)를 지원하지 않는 언어에서 일급 함수 기능 흉내 가능
    5. 조건문 분해하기 (Decompose Conditional)
        - **조건**과 **액션** 모두 **의도**를 표현해야함
        - 코드 분해 후 각 코드 덩어리를 의도를 살린 이름의 함수 호출로 변경
        - 1. 해당 **조건**이 무엇인지 강조하고, 2. **무엇**을 분기했는지, 3. **왜** 분기했는지 명확하게 변경
    6. 반복문 쪼개기 (Split Loop)
       - 서로 다른 일이 한 함수에서 일어나고 있다는 신호일 수도
       - 리팩토링과 최적화 구분하기
    7. 조건문을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)
       - 기본 동작은 슈퍼 클래스로, 각 case는 서브 클래스로

18. 긴 매개변수 목록
    1. 매개변수를 질의 함수로 바꾸기
    19. 플래그 인수 제거하기
    20. 여러 함수를 클래스로 묶기

22. 전역 데이터
    1. 변수 캡슐화 하기
    
23. 가변 데이터
    1. 변수 쪼개기
    25. 질의 함수와 변경 함수 분리하기
    26. 세터 제거하기
    27. 파생 변수를 질의 함수로 바꾸기
    28. 여러 함수를 변환 함수로 묶기
    29. 참조를 값으로 바꾸기
    
30. 뒤엉킨 변경
    1. 단계 쪼개기
    32. 함수 옮기기
    33. 클래스 추출하기
    
34. 산탄총 수술
    1. 필드 옮기기
    36. 함수 인라인
    37. 클래스 인라인
    
38. 기능 편애

39. 데이터 뭉치

40. 기본형 집착
    1. 기본형을 객체로 바꾸기
    42. 타입 코드를 서브 클래스로 바꾸기
    43. 조건부 로직을 다형성으로 바꾸기
    
44. 반복되는 switch문

45. 반복문
    1. 반복문을 파이프라인으로 바꾸기
    
47. 성의없는 요소
    1. 계층 합치기
    
49. 추측성 일반화
    1. 죽은 코드 제거하기
    
51. 임시 필드
    1. 특이 케이스 추가하기
    
53. 메시지 체인
    1. 위임 숨기기
    
55. 중재자
    1. 중재자 제거하기
    57. 슈퍼클래스를 위임으로 바꾸기
    58. 서브클래스를 위임으로 바꾸기
    
59. 내부자 거래

60. 거대한 클래스
    1. 슈퍼클래스 추출하기
    
62. 서로 다른 인터페이스의 대안 클래스들

63. 데이터 클래스
    1. 레코드 캡슐화하기
    
65. 상속 포기

66. 주석
    1. 어셔션 추가하기
    
68. 리팩토링 카탈로그
    1. 기본 기술
    70. 캡슐화
    71. 기능 옮기기
    72. 데이터 조직화
    73. 조건부 로직 간소화
    74. API 리팩토링
    75. 상속 다루기
